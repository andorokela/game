<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Обнаружение границ с помощью Canny</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 24px;
      text-align: center;
    }
    canvas {
      border: 1px solid #000;
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .controls label {
      font-size: 16px;
    }
    .controls input[type="range"] {
      width: 100%;
    }
    .controls button {
      padding: 10px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-container span {
      font-size: 16px;
      min-width: 40px;
      text-align: right;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
    }
    .file-input-container button {
      flex: 1;
    }
    video {
      display: none; /* Скрываем видеоэлемент */
    }
    #captureButton {
      display: none; /* Скрываем кнопку "Сделать снимок" по умолчанию */
    }
  </style>
</head>
<body>
  <h1>Обнаружение границ с помощью Canny</h1>
  <div class="controls">
    <div class="file-input-container">
      <button id="filePickerButton">Выбрать файл</button>
      <button id="cameraButton">Сделать фото</button>
      <button id="captureButton">Сделать снимок</button>
    </div>

    <!-- Поле для выбора файла -->
    <input type="file" id="imageInput" accept="image/*" style="display: none;" />

    <!-- Видеоэлемент для камеры -->
    <video id="video" autoplay></video>

    <div class="slider-container">
      <label for="threshold1">Порог 1:</label>
      <input type="range" id="threshold1" min="0" max="500" value="100" />
      <span id="threshold1Value">100</span>
    </div>

    <div class="slider-container">
      <label for="threshold2">Порог 2:</label>
      <input type="range" id="threshold2" min="0" max="500" value="200" />
      <span id="threshold2Value">200</span>
    </div>

    <button id="applyCannyButton">Применить Canny</button>
    <button id="saveSvgButton">Сохранить SVG</button> <!-- Новая кнопка -->
  </div>
  <canvas id="canvas"></canvas>

  <!-- Локальная библиотека OpenCV.js -->
  <script src="opencv.js" type="text/javascript"></script>
  <script>
    // Ждем полной загрузки DOM перед выполнением скрипта
    document.addEventListener('DOMContentLoaded', function () {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const video = document.getElementById('video');
      const captureButton = document.getElementById('captureButton');
      const filePickerButton = document.getElementById('filePickerButton');
      const cameraButton = document.getElementById('cameraButton');
      const applyCannyButton = document.getElementById('applyCannyButton');
      const saveSvgButton = document.getElementById('saveSvgButton'); // Новая кнопка
      let img;
      let isCameraActive = false;
      let isOpenCvReady = false;

      // Элементы управления
      const threshold1Input = document.getElementById('threshold1');
      const threshold2Input = document.getElementById('threshold2');

      // Числовые значения
      const threshold1Value = document.getElementById('threshold1Value');
      const threshold2Value = document.getElementById('threshold2Value');

      // Проверка, что элементы существуют
      if (!threshold1Input || !threshold2Input || !threshold1Value || !threshold2Value) {
        console.error("Один или несколько элементов управления не найдены в DOM.");
        return;
      }

      // Обновление числовых значений
      threshold1Input.addEventListener('input', () => {
        threshold1Value.textContent = threshold1Input.value;
        applyCanny(); // Применяем фильтр Canny при изменении ползунка
      });
      threshold2Input.addEventListener('input', () => {
        threshold2Value.textContent = threshold2Input.value;
        applyCanny(); // Применяем фильтр Canny при изменении ползунка
      });

      // Функция для открытия файлового picker
      function openFilePicker() {
        const input = document.getElementById('imageInput');
        input.click();
      }

      // Функция для открытия камеры
      async function openCamera() {
        if (isCameraActive) return;

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          video.srcObject = stream;
          video.play();
          isCameraActive = true;
          captureButton.style.display = 'block';
          requestAnimationFrame(drawCameraFrame);
        } catch (error) {
          alert('Не удалось получить доступ к камере: ' + error.message);
        }
      }

      // Функция для отрисовки кадров с камеры на холсте
      function drawCameraFrame() {
        if (!isCameraActive) return;

        const maxWidth = window.innerWidth * 0.9;
        const aspectRatio = video.videoWidth / video.videoHeight;
        canvas.width = maxWidth;
        canvas.height = maxWidth / aspectRatio;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        requestAnimationFrame(drawCameraFrame);
      }

      // Функция для захвата фото с камеры
      function capturePhoto() {
        if (!isCameraActive) return;

        const stream = video.srcObject;
        const tracks = stream.getTracks();
        tracks.forEach(track => track.stop());
        video.srcObject = null;
        isCameraActive = false;
        captureButton.style.display = 'none';

        img = new Image();
        img.src = canvas.toDataURL('image/png');
        img.onload = function () {
          const maxWidth = window.innerWidth * 0.9;
          const aspectRatio = img.width / img.height;
          canvas.width = maxWidth;
          canvas.height = maxWidth / aspectRatio;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
      }

      // Функция для загрузки изображения
      document.getElementById('imageInput').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            img = new Image();
            img.src = e.target.result;
            img.onload = function () {
              const maxWidth = window.innerWidth * 0.9;
              const aspectRatio = img.width / img.height;
              canvas.width = maxWidth;
              canvas.height = maxWidth / aspectRatio;

              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
          };
          reader.readAsDataURL(file);
        }
      });

      // Функция для применения фильтра Canny
      function applyCanny() {
        if (!isOpenCvReady) {
          alert("OpenCV.js не загружен. Подождите, пока библиотека загрузится.");
          return;
        }

        if (!img && !isCameraActive) {
          alert('Сначала загрузите изображение или включите камеру!');
          return;
        }

        const threshold1 = parseInt(threshold1Input.value);
        const threshold2 = parseInt(threshold2Input.value);

        // Создаем временный холст для обработки изображения
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Рисуем изображение на временном холсте
        if (isCameraActive) {
          tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
        } else {
          tempCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        // Получаем данные изображения
        const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);

        // Создаем матрицу для OpenCV
        const src = cv.matFromImageData(imageData);
        const dst = new cv.Mat();

        // Преобразуем изображение в оттенки серого
        cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);

        // Применяем фильтр Canny
        cv.Canny(src, dst, threshold1, threshold2);

        // Преобразуем результат обратно в формат RGBA
        const rgbaDst = new cv.Mat();
        cv.cvtColor(dst, rgbaDst, cv.COLOR_GRAY2RGBA, 0);

        // Преобразуем результат обратно в изображение
        const resultImageData = new ImageData(
          new Uint8ClampedArray(rgbaDst.data),
          rgbaDst.cols,
          rgbaDst.rows
        );

        // Очищаем основной холст и рисуем результат
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(resultImageData, 0, 0);

        // Освобождаем ресурсы
        src.delete();
        dst.delete();
        rgbaDst.delete();
      }

      // Функция для упрощения контуров с помощью алгоритма Рамера-Дугласа-Пекера
      function simplifyContour(points, epsilon) {
        if (points.length <= 2) return points;

        // Находим точку с максимальным отклонением
        let dmax = 0;
        let index = 0;
        const end = points.length - 1;

        for (let i = 1; i < end; i++) {
          const d = perpendicularDistance(points[i], points[0], points[end]);
          if (d > dmax) {
            index = i;
            dmax = d;
          }
        }

        // Если максимальное отклонение больше epsilon, рекурсивно упрощаем
        if (dmax > epsilon) {
          const left = simplifyContour(points.slice(0, index + 1), epsilon);
          const right = simplifyContour(points.slice(index), epsilon);
          return left.slice(0, -1).concat(right);
        } else {
          return [points[0], points[end]];
        }
      }

      // Функция для вычисления перпендикулярного расстояния от точки до линии
      function perpendicularDistance(point, lineStart, lineEnd) {
        const area = Math.abs(
          (lineEnd.x - lineStart.x) * (lineStart.y - point.y) -
          (lineStart.x - point.x) * (lineEnd.y - lineStart.y)
        );
        const lineLength = Math.sqrt(
          (lineEnd.x - lineStart.x) ** 2 + (lineEnd.y - lineStart.y) ** 2
        );
        return area / lineLength;
      }

      // Функция для сохранения результата в SVG с упрощением векторов
      // Функция для упрощения контуров с помощью алгоритма Рамера-Дугласа-Пекера
      function simplifyContour(points, epsilon) {
        if (points.length <= 2) return points;

        // Находим точку с максимальным отклонением
        let dmax = 0;
        let index = 0;
        const end = points.length - 1;

        for (let i = 1; i < end; i++) {
          const d = perpendicularDistance(points[i], points[0], points[end]);
          if (d > dmax) {
            index = i;
            dmax = d;
          }
        }

        // Если максимальное отклонение больше epsilon, рекурсивно упрощаем
        if (dmax > epsilon) {
          const left = simplifyContour(points.slice(0, index + 1), epsilon);
          const right = simplifyContour(points.slice(index), epsilon);
          return left.slice(0, -1).concat(right);
        } else {
          return [points[0], points[end]];
        }
      }

      // Функция для вычисления перпендикулярного расстояния от точки до линии
      function perpendicularDistance(point, lineStart, lineEnd) {
        const area = Math.abs(
          (lineEnd.x - lineStart.x) * (lineStart.y - point.y) -
          (lineStart.x - point.x) * (lineEnd.y - lineStart.y)
        );
        const lineLength = Math.sqrt(
          (lineEnd.x - lineStart.x) ** 2 + (lineEnd.y - lineStart.y) ** 2
        );
        return area / lineLength;
      }

      // Функция для сохранения результата в SVG с упрощением векторов
      function saveAsSvg() {
        if (!canvas || !ctx) {
          alert("Нет данных для сохранения.");
          return;
        }

        // Получаем данные изображения с холста
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Создаем временный холст для обработки изображения
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(imageData, 0, 0);

        // Преобразуем изображение в оттенки серого
        const src = cv.imread(tempCanvas);
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        // Применяем пороговую обработку для получения бинарного изображения
        const binary = new cv.Mat();
        cv.threshold(gray, binary, 128, 255, cv.THRESH_BINARY);

        // Находим контуры
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(binary, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        // Создаем SVG-элемент
        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">\n`;

        // Обрабатываем каждый контур
        for (let i = 0; i < contours.size(); i++) {
          const contour = contours.get(i);
          const points = [];

          // Преобразуем контур в массив точек
          for (let j = 0; j < contour.rows; j++) {
            const point = contour.data32S.slice(j * 2, j * 2 + 2);
            points.push({ x: point[0], y: point[1] });
          }

          // Упрощаем контур
          const epsilon = 1; // Параметр упрощения (можно регулировать)
          const simplifiedPoints = simplifyContour(points, epsilon);

          // Создаем SVG-путь для упрощенного контура
          if (simplifiedPoints.length > 1) {
            svgContent += `<path d="M`;
            simplifiedPoints.forEach((point, index) => {
              svgContent += `${point.x} ${point.y} `;
              if (index === 0) svgContent += 'L';
            });
            svgContent += `" fill="none" stroke="black" stroke-width="1" />\n`;
          }
        }

        svgContent += `</svg>`;

        // Освобождаем ресурсы OpenCV
        src.delete();
        gray.delete();
        binary.delete();
        contours.delete();
        hierarchy.delete();

        // Создаем Blob и ссылку для скачивания
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'canny_edges_simplified.svg';
        a.click();
        URL.revokeObjectURL(url);
      }

      // Назначаем обработчики событий
      filePickerButton.addEventListener('click', openFilePicker);
      cameraButton.addEventListener('click', openCamera);
      captureButton.addEventListener('click', capturePhoto);
      applyCannyButton.addEventListener('click', applyCanny);
      saveSvgButton.addEventListener('click', saveAsSvg); // Обработчик для новой кнопки

      // Функция для проверки загрузки OpenCV
      function onOpenCvReady() {
        isOpenCvReady = true;
        console.log("OpenCV.js загружен и готов к использованию.");
      }

      // Проверка загрузки OpenCV
      cv['onRuntimeInitialized'] = onOpenCvReady;
    });
  </script>
</body>
</html>
