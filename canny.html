<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Обнаружение границ с помощью Canny</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f4f4f4;
    }
    h1 {
      font-size: 24px;
      text-align: center;
    }
    canvas {
      border: 1px solid #000;
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    .controls {
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .controls label {
      font-size: 16px;
    }
    .controls input[type="range"] {
      width: 100%;
    }
    .controls button {
      padding: 10px;
      font-size: 16px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .controls button:hover {
      background-color: #0056b3;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-container span {
      font-size: 16px;
      min-width: 40px;
      text-align: right;
    }
    .file-input-container {
      display: flex;
      gap: 10px;
    }
    .file-input-container button {
      flex: 1;
    }
    video {
      display: none; /* Скрываем видеоэлемент */
    }
    #captureButton {
      display: none; /* Скрываем кнопку "Сделать снимок" по умолчанию */
    }
  </style>
</head>
<body>
  <h1>Обнаружение границ с помощью Canny</h1>
  <div class="controls">
    <div class="file-input-container">
      <button id="filePickerButton">Выбрать файл</button>
      <button id="cameraButton">Сделать фото</button>
      <button id="captureButton">Сделать снимок</button>
      <button id="switchCameraButton">Сменить камеру</button> <!-- Новая кнопка -->
    </div>

    <!-- Поле для выбора файла -->
    <input type="file" id="imageInput" accept="image/*" style="display: none;" />

    <!-- Видеоэлемент для камеры -->
    <video id="video" autoplay></video>

    <div class="slider-container">
      <label for="threshold1">Порог 1:</label>
      <input type="range" id="threshold1" min="0" max="500" value="100" />
      <span id="threshold1Value">100</span>
    </div>

    <div class="slider-container">
      <label for="threshold2">Порог 2:</label>
      <input type="range" id="threshold2" min="0" max="500" value="200" />
      <span id="threshold2Value">200</span>
    </div>

    <button id="applyCannyButton">Применить Canny</button>
    <button id="saveSvgButton">Сохранить SVG</button>
  </div>
  <canvas id="canvas"></canvas>

  <!-- Локальная библиотека OpenCV.js -->
  <script src="https://andorokela.github.io/game/opencv.js" type="text/javascript"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const video = document.getElementById('video');
      const captureButton = document.getElementById('captureButton');
      const filePickerButton = document.getElementById('filePickerButton');
      const cameraButton = document.getElementById('cameraButton');
      const switchCameraButton = document.getElementById('switchCameraButton'); // Новая кнопка
      const applyCannyButton = document.getElementById('applyCannyButton');
      const saveSvgButton = document.getElementById('saveSvgButton');
      let img;
      let isCameraActive = false;
      let currentFacingMode = 'environment'; // По умолчанию задняя камера
      let stream;

      // Функция для открытия файлового picker
      function openFilePicker() {
        const input = document.getElementById('imageInput');
        input.click();
      }

      // Функция для загрузки изображения
      document.getElementById('imageInput').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            img = new Image();
            img.src = e.target.result;
            img.onload = function () {
              const maxWidth = window.innerWidth * 0.9;
              const aspectRatio = img.width / img.height;
              canvas.width = maxWidth;
              canvas.height = maxWidth / aspectRatio;

              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
          };
          reader.readAsDataURL(file);
        }
      });

      // Функция для запуска камеры с указанной стороной (front или back)
      async function startCamera(facingMode) {
        if (isCameraActive) {
          // Останавливаем текущий поток
          stream.getTracks().forEach(track => track.stop());
        }

        try {
          const constraints = {
            video: { facingMode: facingMode }
          };
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          video.play();
          isCameraActive = true;
          captureButton.style.display = 'block';
          currentFacingMode = facingMode;
          requestAnimationFrame(drawCameraFrame);
        } catch (error) {
          alert('Не удалось получить доступ к камере: ' + error.message);
        }
      }

      // Функция для переключения камеры
      function switchCamera() {
        if (currentFacingMode === 'environment') {
          startCamera('user'); // Переключаем на фронтальную камеру
        } else {
          startCamera('environment'); // Переключаем на заднюю камеру
        }
      }

      // Функция для отрисовки кадров с камеры на холсте
      function drawCameraFrame() {
        if (!isCameraActive) return;

        const maxWidth = window.innerWidth * 0.9;
        const aspectRatio = video.videoWidth / video.videoHeight;
        canvas.width = maxWidth;
        canvas.height = maxWidth / aspectRatio;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        requestAnimationFrame(drawCameraFrame);
      }

      // Функция для захвата фото с камеры
      function capturePhoto() {
        if (!isCameraActive) return;

        stream.getTracks().forEach(track => track.stop());
        video.srcObject = null;
        isCameraActive = false;
        captureButton.style.display = 'none';

        img = new Image();
        img.src = canvas.toDataURL('image/png');
        img.onload = function () {
          const maxWidth = window.innerWidth * 0.9;
          const aspectRatio = img.width / img.height;
          canvas.width = maxWidth;
          canvas.height = maxWidth / aspectRatio;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
      }

      // Функция для применения фильтра Canny
      function applyCanny() {
        if (!img && !isCameraActive) {
          alert('Сначала загрузите изображение или включите камеру!');
          return;
        }

        const threshold1 = parseInt(threshold1Input.value);
        const threshold2 = parseInt(threshold2Input.value);

        // Создаем временный холст для обработки изображения
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Рисуем изображение на временном холсте
        if (isCameraActive) {
          tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
        } else {
          tempCtx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        // Получаем данные изображения
        const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);

        // Создаем матрицу для OpenCV
        const src = cv.matFromImageData(imageData);
        const dst = new cv.Mat();

        // Преобразуем изображение в оттенки серого
        cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);

        // Применяем фильтр Canny
        cv.Canny(src, dst, threshold1, threshold2);

        // Преобразуем результат обратно в формат RGBA
        const rgbaDst = new cv.Mat();
        cv.cvtColor(dst, rgbaDst, cv.COLOR_GRAY2RGBA, 0);

        // Преобразуем результат обратно в изображение
        const resultImageData = new ImageData(
          new Uint8ClampedArray(rgbaDst.data),
          rgbaDst.cols,
          rgbaDst.rows
        );

        // Очищаем основной холст и рисуем результат
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.putImageData(resultImageData, 0, 0);

        // Освобождаем ресурсы
        src.delete();
        dst.delete();
        rgbaDst.delete();
      }

      // Функция для сохранения результата в SVG
      function saveAsSvg() {
        if (!canvas || !ctx) {
          alert("Нет данных для сохранения.");
          return;
        }

        // Получаем данные изображения с холста
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Создаем SVG-элемент
        let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">\n`;

        // Собираем все точки границ
        const points = [];
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const index = (y * canvas.width + x) * 4;
            const alpha = pixels[index + 3];
            if (alpha > 0) { // Если пиксель не прозрачный
              points.push({ x, y });
            }
          }
        }

        // Упрощаем контуры
        const epsilon = 1; // Параметр упрощения (можно регулировать)
        const simplifiedPoints = simplifyContour(points, epsilon);

        // Создаем SVG-пути на основе упрощенных точек
        svgContent += `<path d="M`;
        simplifiedPoints.forEach((point, index) => {
          svgContent += `${point.x} ${point.y} `;
          if (index === 0) svgContent += 'L';
        });
        svgContent += `" fill="none" stroke="black" stroke-width="1" />\n`;

        svgContent += `</svg>`;

        // Создаем Blob и ссылку для скачивания
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'canny_edges_simplified.svg';
        a.click();
        URL.revokeObjectURL(url);
      }

      // Функция для упрощения контуров с помощью алгоритма Рамера-Дугласа-Пекера
      function simplifyContour(points, epsilon) {
        if (points.length <= 2) return points;

        // Находим точку с максимальным отклонением
        let dmax = 0;
        let index = 0;
        const end = points.length - 1;

        for (let i = 1; i < end; i++) {
          const d = perpendicularDistance(points[i], points[0], points[end]);
          if (d > dmax) {
            index = i;
            dmax = d;
          }
        }

        // Если максимальное отклонение больше epsilon, рекурсивно упрощаем
        if (dmax > epsilon) {
          const left = simplifyContour(points.slice(0, index + 1), epsilon);
          const right = simplifyContour(points.slice(index), epsilon);
          return left.slice(0, -1).concat(right);
        } else {
          return [points[0], points[end]];
        }
      }

      // Функция для вычисления перпендикулярного расстояния от точки до линии
      function perpendicularDistance(point, lineStart, lineEnd) {
        const area = Math.abs(
          (lineEnd.x - lineStart.x) * (lineStart.y - point.y) -
          (lineStart.x - point.x) * (lineEnd.y - lineStart.y)
        );
        const lineLength = Math.sqrt(
          (lineEnd.x - lineStart.x) ** 2 + (lineEnd.y - lineStart.y) ** 2
        );
        return area / lineLength;
      }

      // Назначаем обработчики событий
      filePickerButton.addEventListener('click', openFilePicker);
      cameraButton.addEventListener('click', () => startCamera(currentFacingMode));
      captureButton.addEventListener('click', capturePhoto);
      switchCameraButton.addEventListener('click', switchCamera); // Обработчик для новой кнопки
      applyCannyButton.addEventListener('click', applyCanny);
      saveSvgButton.addEventListener('click', saveAsSvg);
    });
  </script>
</body>
</html>
